Первый вопрос
* Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах распространения событий на практике?

	Event propagination - это процесс распространения события по дереву DOM, которое активируется при каком-либо действии над
	элементами DOM, к примеру клике, вводе, фокусе итд. Я имею ввиду, что событие, проходит по DOM дереву. К примеру когда
	пользователь кликает по кнопке, событие идет как-будто сверху вниз, именно поэтому оно проходит через родителей, поэтому
	можно обработчики могут прицепиться не только к элементу, который вызывает событие но и к его родителям. И не только к
	родителям элемента активатора, но и к родителям родителя, так можно дойти хоть до корня DOM дерева document и до глобального
	окружения браузера window. Поэтому браузер определяет путь события или же event path и вызывает обработчики по фазам.
	Так же важно отметить, как это отображено в коде, если нужно обратиться к реальному элементу на котором произошло действие,
	то это event.target, а если же нам нужен элемент на котором исполняется обработчик, то это element.currentTarget.

  Обычно выделяют 3 фазы распространения событий:
  - Первая фаза - это перехват или же capturing. Событие идет сверху вниз и проходит через window, document, html, body и так до
  элемента на котором произошло действие. На этой фазе сработают только те обработчики, которые подписались на захват capture.

  - Вторая фаза - это фаза цели или же Target phase. Оно так называется потому что на этой фазе событие достигло цели и на том
  элементе запускаются обработчики, они могут быть подписаны как на capture так и на bubble.

  - Третья фаза - это буквально всплытие (bubbling), так как событие идет снизу вверх, то есть от цели target и до window,
  проходя тот же самый путь, что и при первой фазе, но наоборот. По умолчанию большинство событий слушаются на этой фазе.

  Важное уточнение про третью фазу bubbling, большая часть событий действительно всплывает, такие как click, input, submit…
  но есть исключения, такие как blur и focus, но есть focusin и focusout, а вот они уже всплывают.

  Практическое применение фаз:
  1. Делегирование событий (event delegation) - главная суть этой практики состоит в том, чтобы повесить один обработчик на
  общего родителя, к примеру если нужно обрабатывать много кнопок за раз. И таким образом можно ловить события снизу, благодаря bubbling.

  2. Польза перехвата - иногда нужно поймать событие до того как оно дойдет до цели. Очень типичный пример: закрытие модалки по клику вне окна.

  3. Контроль вложенных кликов, к примеру есть карточка товара, и в ней есть кнопка для добавления в избранное, при клике на карточку должна
  открыться страница товара. Благодаря распространению событий, можно сделать так чтобы клик полученный на кнопке не всплыл до карточки при помощи
  stopPropagination(), таким образом, клик по кнопке не откроет страницу товара.

  4. Это просто полезно для оптимизации, если в проекте очень много элементов, с запутанным деревом и частое обновление DOM при поиске к примеру,
  то делегирование может спасти ситуацию.


Второй вопрос
* Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать
асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?

	Promise в JavaScript - это такой объект который представляет результат асинхронной операции, он либо успешно выполнится или же завершится ошибкой.
	Идея этого объекта очень хорошо передана в его названии, Promise - это обещание, вернуть значение позже. Благодаря нему, не блокируется основной поток.
	Он работает по таким шагам: создается, потом запускается асинхронная операция (запрос, таймер, чтение данных), далее он переходит из ожидающего (pending),
	так как еще не известно, какой будет результат успешный или нет. Поэтому он переходит в fulfilled если операция успешна или в rejected в случае ошибки.
	Таким образом у promise есть три состояния: pending, fulfilled и rejected, и важно отметить, что он меняет состояние только один раз из pending
	либо fulfilled или rejected, обратно он вернуться не может.

	Асинхронный код в JavaScript можно обрабатывать так же с помощью синтаксического сахара async / await. Это дополнение к promise, оно делает код более
	читаемым и похожим на синхронный. Помимо этого можно использовать callback функции - это более ранний подход, при котором логика передается в функцию
	обратного вызова, но у этого метода есть свои изъяны, такие как вложенность, порой она становится просто очень сложной и читать код становится очень
	сложно, до сих пор помню когда смотрел видео на английском про express.js и там я впервые услышал про такой термин как callback hell,
	это когда очень много callback :) Именно поэтому предпочтительнее использовать Promise и async / await.

	Event Loop играет что ни на есть очень важную роль, в асинхронности. По сути JavaScript по модели выполнения является однопоточным, но приложения должны делать
	много вещей одновременно, вот для этого и нужен Event Loop, он делает так что: синхронный код выполняется сразу, долгие операции выполняются вне стека JavaScript
	(окружением), а результаты сложных операций возвращаются в стек позже, в правильном порядке. Есть Call Stack он выполняет синхронный код, если туда попадет
	сложная задача, но приложение зависнет, именно поэтому есть окружение - это внешние возможности браузера, они выполняют сложные операции к примеру
	setTimeout и Fetch. Когда внешняя операция готова, то ее callback попадает в очередь, Event Loop перемещает его в Call Stack и там он выполняется. Из этих
	сложных операций, образуется две очереди: Macrotask queue (туда попадает setTimeout, setInterval) и Microtask queue (туда попадают обработчики Promise: then,
	catch, finally). Event Loop  делает следующее, сначала выполняет синхронный код пока Call Stack не станет пустым, затем идут все "микро задачи",
	затем он берет одну "макро задачу" и цикл повторяется. В этом и заключается роль Event Loop в асинхронности, без него при одном setTimeout приложение
	просто бы застыло, но с ним, эта задача уйдет окружение, не остановив основной поток, когда таймер будет готов, callback попадет в очередь и Event Loop
	выполнит его когда стек свободен.


Третий вопрос
* Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том,
как ООП реализовано в JavaScript.

  ООП (Объектно ориентированное программирование) - это парадигма программирования, при которой программа состоит из объектов, то есть сущностей,
  объединяющих данные (состояние) и поведение (методы). Этот подход позволяет писать понятный, переиспользуемый и расширяемый код.

  Ключевые принципы это:
  1. Инкапсуляция - этот принцип ООП состоит в сокрытии внутренних деталей реализации объекта и в предоставлении наружу понятного интерфейса для работы с ним.
  Пользователь объекта не обязан знать, как именно он устроен, так как взаимодействовать нужно исключительно через публичные методы. Такой подход позволяет
  защитить состояние объекта от некорректных изменений.

    class BankAccount {
      #balance = 0;

      deposit(amount) {
        if (amount <= 0) return;
        this.#balance += amount;
      }

      withdraw(amount) {
        if (amount <= 0 || amount > this.#balance) return;
        this.#balance -= amount;
      }

      getBalance() {
        return this.#balance;
      }
    }

    const account = new BankAccount();
    account.deposit(100);
    account.withdraw(30);

    console.log(account.getBalance());

  В приведенном примере баланс банковского счета является внутренним состоянием объекта и оно скрыто от прямого доступа извне. Изменение баланса
  возможно только через методы deposit и withdraw, которые содержат проверки корректности операций. Таким образом, инкапсуляция гарантирует,
  что не будет случайного изменения данных, что было бы фатально если мы говорим про банк.

  2. Абстракция - это принцип ООП, который заключается в выделении ключевой функциональности и сокрытии деталий реализации. Объект должен
  предоставлять набор необходимых операций для работы с ним, не раскрывая того, как именно они реализованы, в этом и стоит принцип абстракции.
  Таким образом код становится проще понять и использовать.

  Очень хорошая аналогия это - медиаплеер предоставляет методы play и pause, но пользователю не нужно знать как они устроены, знать про
  буферизацию данных или декодирование аудио, достаточно лишь использовать интерфейс.

  В JavaScript абстракция достигается через интерфейс класса или модуля, то есть через набор его публичных методов и свойств, которые формируют контракт.
  Также абстракция достигается за счет логического разделения кода на разные слои, пример из моего приложения это movie-api-service,
  он скрывает детали работы с api, предоставляя простой и понятный интерфейс для получения данных.

  3. Наследование - это принцип ООП, основанный на переиспользовании существующего кода за счет создания новых классов на основе уже существующих.
  Как это работает, дочерний класс наследует свойства и методы родительского класса, а также может расширять или менять его функциональность под свои нужды.
  Данный подход позволяет избежать дублирования кода и помогает поддерживать единые правила для связанных сущностей.

    class BaseEntity {
      constructor(id) {
        this.id = id;
        this.createdAt = new Date();
      }

      getInfo() {
        return `Entity's id #${this.id}`;
      }
    }

    class User extends BaseEntity {
      getInfo() {
        return `User's id #${this.id}`;
      }
    }

    const user = new User(1);
    console.log(user.getInfo());

  В этом примере класс BaseEntity содержит общие свойства и базовый метод. Класс User наследуется от BaseEntity, но переопределяет метод getInfo,
  этот пример хорошо показывает потенциал переиспользования кода и возможность его расширения, с помощью наследования.

  4. Полиморфизм - это принцип ООП, при котором разные объекты могут по-разному реагировать на вызов одного и того же метода в зависимости от своей реализации.
  Код работает не с конкретным типом объекта, а с его поведением, что позволяет использовать разные реализации без изменения логики использования.

  В JavaScript полиморфизм чаще всего реализуется за счет утиной типизации: объект считается подходящим, если он предоставляет необходимый набор методов
  независимо от того, к какому классу он принадлежит.

  Пример полиморфизма JavaScript:

    class FileLogger {
      log(message) {
        console.log(`File: message is recieved ${message}`);
      }
    }

    class HttpLogger {
      log(message) {
        console.log(`HTTP: message is recieved ${message}`);
      }
    }

    function writeLog(logger) {
      logger.log('Operation is completed');
    }

    writeLog(new FileLogger());
    writeLog(new HttpLogger());

  В этом примере функция writeLog работает с любым объектом, обладающим методом log. Несмотря на то что классы FileLogger и HttpLogger
  реализуют этот метод по-разному, они могут быть использованными взаимозаменяемо. Этот пример хорошо демонстрирует полиморфизм
  и отражает особенность JavaScript - утиную типизацию, о которой было сказано выше.

ООП в JavaScript

  1. JavaScript - это прототипный язык, то есть наследование происходит не от класса, а от конкретного объекта, в отличие от объектно ориентированных языков
  таких как c# или java. В JavaScript исторически не было классов, а слово prototype означает первый образец, модель с которой наследуется поведение.

  Прототип в JavaScript - это объект, которому другой объект делегирует доступ к  свойствам и методам. Это называется delegation то есть делегирование,
  оно работает через цепочку прототипов.

  Каждый объект в JavaScript имеет скрытую внутреннюю ссылку [[Prototype]], которая указывает на другой объект. Если при обращении к свойству или методу,
  JavaScript не находит его в самом объекте, он автоматически ищет его выше по цепочке прототипов. Получить прототип объекта можно
  с помощью Object.getPrototypeOf, а установить через Object.create.

  Пример прототипного наследования в JavaScript:

    const baseEntity = {
      getInformation() {
        return `Entity`;
      }
    };

    const user = Object.create(baseEntity);
    user.name = 'Alex';
    user.getInformation = function () {
      return `User: ${this.name}`;
    };

    console.log(user.getInformation());
    console.log(Object.getPrototypeOf(user) === baseEntity);

  В этом примере объект user наследует поведение от объекта baseEntity. Если бы метод getInformation не был определен в user, он был бы найден
  в прототипе baseEntity. Такой процесс наследования, через цепочку прототипов лежит в основе объектной модели JavaScript и используется даже тогда,
  когда мы работаем с class, который является лишь удобной оберткой над прототипной системой.

  2. Ключевое слово class в Javascript - это синтаксический сахар над прототипной системой. Это ключевое слово было добавлено, для упрощения создания
  объектов и работы с наследованием, это позволило сделать код более привычным для разработчиков пришедших с объектно ориентированных языков.
  Несмотря на использование синтаксиса классов, JavaScript остается прототипным и по-прежнему использует прототипы и цепочку прототипов для
  поиска свойств и методов.

  При объявлении класса методы не копируются в каждый объект, а размещаются в прототипе. Экземпляры класса лишь содержат ссылку на тот прототип,
  что полностью соответствует прототипной модели наследования.

  Пример использования class в JavaScript:

    class BaseEntity {
      constructor(id) {
        this.id = id;
      }

      getId() {
        return `Entity #${this.id}`;
      }
    }

    const entity = new BaseEntity(1);
    console.log(entity.getId());

  В данном примере метод getId на самом деле находится в BaseEntity.prototype, а объект entity при вызове метода обращается к нему через цепочку прототипов.
  Таким образом синтаксис class не вводит классическое наследование типов, а лишь предоставляет более удобный и читаемый способ работы с прототипами.

  3. До появления синтаксиса class, в JavaScript для создания объектов использовались функции-конструкторы. Такая функция вызывается оператором new,
  он создает новый объект, и связывает его с прототипом функции и передает его в контекст this. Общие методы размещаются в прототип функции-конструктора
  и они доступны всем экземплярам через цепочку прототипов.

  Благодаря функциям-конструкторам еще до классов, можно было переиспользовать код путем
  наследования. Но и были проблемы, в частности это необходимость более аккуратной работы с прототипами и соглашениями, поэтому был добавлен
  синтаксис class, как более удобная альтернатива.

  Пример использования функции-конструктора:

    function BaseEntity(id) {
      this.id = id;
    }

    BaseEntity.prototype.getId = function () {
      return this.id;
    };

    const entity = new BaseEntity(1);
    console.log(entity.getId());

  В данном примере функция BaseEntity используется как конструктор для создания объектов, а метод getId размещен в ее прототипе.
  Экземпляр entity получает доступ к этому методу через цепочку прототипов.

  4. В JavaScript приватность и инкапсуляция реализуются несколькими способами, так как язык изначально не имел строгих модификаторов доступа.
  На практике используются приватные поля классов, замыкания и модульная система ES. Все эти подходы позволяют скрывать детали реализации и предоставлять
  наружу только публичный api.

  Приватные поля (обозначаемые символом #) позволяют скрывать внутреннее состояние класса делают его недоступным извне, защищая данные от прямого изменения.

  Замыкания обеспечивают приватность за счет области видимости: переменные, объявленные внутри функции доступны только вложенным функциям и скрыты от внешнего кода.

  ES модули (export, import) реализуют инкапсуляцию на уровне файлов, все что не экспортировано, остается внутренней деталью реализации, а наружу выносят
  только публичный api.

  Пример сочетание инкапсуляции и приватности с использованием класса и приватного поля:

    class UserSession {
      #token;

      constructor(token) {
        this.#token = token;
      }

      isAuthorized() {
        return Boolean(this.#token);
      }

      clear() {
        this.#token = null;
      }
    }

    const session = new UserSession('token');
    console.log(session.isAuthorized());
    session.clear();
    console.log(session.isAuthorized());

  В этом примере токен сессии является внутренним состоянием объекта и он скрыт с помощью приватного поля. Внешний код не имеет прямого доступа к токену
  и может работать с состоянием сессии только через публичные методы. Такой подход иллюстрирует принцип инкапсуляции.

  5. Полиморфизм в JavaScript, как уже было описано выше, чаще всего реализуется за счет утиной типизации и не требует обязательного наследования.
  В рамках реализации ООП в JavaScript важно отметить, что язык ориентируется не на тип объекта, а на его поведение: достаточно, чтобы объект
  предоставлял необходимый набор методов. Это позволяет использовать разные реализации взаимозаменяемо без жесткой привязки к классам или иерархии наследования.

  Такой подход является особенностью JavaScript и отличает его от классических объектно-ориентированных языков. При этом отсутствие строгой проверки контрактов
  на уровне языка накладывает дополнительную ответственность на разработчика и требует аккуратного проектирования интерфейсов взаимодействия между объектами.

  6. В JavaScript вместо глубоких иерархий наследования часто предпочтительнее использовать композицию. Суть этого подхода заключается в том,
  что объект не наследует поведение от одного родительского класса, а собирается из нескольких независимых частей, каждая из которых
  отвечает за свою зону ответственности. Такой способ проектирования делает код более гибким, упрощает расширение функциональности
  и снижает связанность между сущностями.

  Композиция позволяет собрать объект так, что все добавленные методы работают в одном контексте this. Благодаря этому методы, полученные из разных частей,
  могут свободно взаимодействовать между собой, обращаясь к общему состоянию объекта, так, если бы они были определены в одном месте.

  Композиция особенно хорошо подходит для JavaScript, так как язык динамический и ориентирован на работу с объектами, а не на строгие иерархии типов.
  Вместо создания сложного дерева классов поведения можно комбинировать, добавляя или заменяя отдельные модули без изменения существующего кода.

  Пример композиции в JavaScript:

    const withLogging = () => ({
      log(message) {
        console.log(message);
      }
    });

    const withTimestamp = () => ({
      getTimestamp() {
        return new Date().toISOString();
      }
    });

    function createRequestHandler() {
      return {
        ...withLogging(),
        ...withTimestamp(),

        handle() {
          this.log(`Request handled at ${this.getTimestamp()}`);
        }
      };
    }

    const handler = createRequestHandler();
    handler.handle();

  В этом примере объект handler не наследуется от базового класса, а собирается из нескольких независимых частей, каждая из которых добавляет свое поведение.


Четвертый вопрос
* Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы.
Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное взаимодействие) могут возникать в процессе?

  Все начинается с того что пользователь вводит url в адресную строку браузера и нажимает Enter, после чего начинается процесс навигации, который состоит из
  нескольких последовательных этапов, а именно от разбора адреса до отображения готовой страницы на экране устройства.

  Сначала браузер анализирует введённый адрес. Он определяет протокол, доменное имя, путь, параметры запроса и якорь. Если протокол не указан явно, браузер обычно
  автоматически использует HTTPS. На этом этапе также учитываются правила безопасности, например если для сайта ранее был включён принудительный HTTPS, браузер сразу
  выполнит переход по защищенному соединению.

  После этого браузер решает, как именно обрабатывать навигацию. Если это полноценный переход на новый документ, он начинает загрузку страницы. Если же адрес меняется
  внутри уже загруженного одностраничного приложения, навигация может быть обработана самим приложением без реального запроса к серверу. Также браузер проверяет,
  можно ли восстановить страницу из истории или кэша, не загружая её заново.

  Перед обращением к сети браузер проверяет, есть ли нужные данные локально. Он смотрит, сохранён ли ответ в HTTP кэше И можно ли его использовать.
  Также запрос может быть перехвачен Service Worker, если он зарегистрирован для данного сайта. В этом случае страница может быть загружена вообще
  без сетевого запроса. Если кэш подходит, браузер либо использует сохранённые данные, либо отправляет условный запрос, чтобы проверить не изменился ли контент.

  Если данные нужно получать из сети, браузеру требуется IP адрес сервера. Для этого выполняется DNS запрос, сначала через локальный кэш, а затем через DNS сервер.
  Получив IP адрес, браузер устанавливает соединение с сервером. Для HTTPS это включает проверку сертификата и настройку защищенного канала. Если соединение с
  сервером уже было открыто ранее и ещё активно, браузер может использовать его повторно, что экономит время.

  Далее браузер отправляет HTTP запрос. Обычно это GET запрос за HTML документом. В запросе передаются заголовки с информацией о браузере, языке, cookies и других
  параметрах. Сервер обрабатывает запрос и возвращает ответ со статусом, заголовками и телом ответа. Это может быть сам HTML документ, редирект на другой адрес или
  сообщение об ошибке.

  Получив HTML, браузер начинает обрабатывать его сразу, не дожидаясь полной загрузки файла. Он постепенно разбирает HTML и строит DOM дерево. Параллельно браузер
  заранее обнаруживает ссылки на дополнительные ресурсы, такие как стили, скрипты, изображения и шрифты, и начинает загружать их как можно раньше.

  Когда загружаются CSS файлы, браузер строит дерево стилей. Оно необходимо для того, чтобы понять, как именно должны выглядеть элементы на странице. JavaScript может
  влиять на этот процесс, некоторые скрипты могут приостанавливать разбор HTML, изменять структуру страницы или стили, поэтому браузер выполняет их в определённые
  моменты, чтобы не нарушать целостность отображения.

  После того как структура страницы и стили достаточно подготовлены, браузер формирует визуальное представление элементов. Он рассчитывает размеры и положение каждого
  блока, текста и изображения. Затем происходит отрисовка то есть браузер рисует содержимое страницы. В современных браузерах часть этой работы выполняется со
  использованием графического процессора.

  В результате пользователь видит первую версию страницы, а затем браузер продолжает работу, он загружает ресурсы, выполняет отложенные скрипты, обрабатывает
  пользовательские действия и при необходимости повторяет этапы пересчета и перерисовки.

Оптимизация ускорение процесса

  О том как можно ускорить процесс. Современные браузеры и веб-платформы используют целый набор технологий, которые позволяют заметно ускорить процесс
  загрузки и сделать отображение страницы более быстрым и плавным для пользователя.

  Одним из ключевых механизмов является кэширование. Браузер может сохранять ответы сервера и повторно использовать и при последующих запросах, если это разрешено
  заголовками. Это позволяет либо полностью избежать сетевого запроса, либо свести его к проверке актуальности данных. Помимо HTTP кеша, важную роль
  играет back/forward cache, который позволяет мгновенно восстанавливать страницу при возврате назад или вперед в истории навигации.

  Существенное влияние на скорость оказывает работа с сетью. Использование keep-alive позволяет избежать повторных установок TCP (протокол, отвечающий за
  установку соединения) и TLS (это уровень шифрования поверх TCP, который используется в HTTPS). Современные версии протокола HTTP, такие как HTTP/2 и HTTP/3,
  снижают задержки за счёт мультиплексирования запросов (передача нескольких запросов и ответов одновременно), более эффективной передачи данных и снижением
  накладных расходов. Дополнительно ускорить загрузку помогает размещение контента на CDN (сеть серверов, которые отдают контент с ближайшей к пользователю точки),
  когда пользователь получает ресурсы с ближайшего к нему сервера.

  На уровне загрузки ресурсов применяются механизмы предварительной загрузки. Браузер может заранее запрашивать важные файлы, такие как стили, шрифты или скрипты,
  ещё до того, как они понадобятся для рендера страницы. Ускорение загрузки ресурсов достигается с помощью preload, prefetch и preconnect. Эти методы позволяют
  сократить время ожидания в критических местах загрузки страницы. Preconnect позволяет браузеру установить сетевое соединение, preload используется для указания
  ресурсов, которые точно понадобятся для отображения страницы, а prefetch в свою очередь загружает ресурсы с низким приоритетом, которые могут понадобиться позже.

  Большое значение имеет оптимизация самого контента. Сжатие данных, например с помощью gzip или brotli, уменьшает объем передаваемой информации. Разделение JavaScript
  кода на чанки и использование ленивой загрузки позволяет не загружать весь код приложения сразу, а подгружает его по мере необходимости. Аналогично работает и
  отложенная загрузка изображений, когда ресурсы подгружаются только тогда, когда они действительно попадают в область видимости пользователя.

Проблемы

  Несмотря на то что браузер берет на себя большую часть работы по загрузке и отображению страницы, в этом процессе могут возникать различные проблемы, связанные
  в первую очередь с безопасностью и междоменным взаимодействием. Эти ограничения существуют не случайно, они направлены на защиту пользователя и его данных.

  Одной из базовых концепций безопасности в браузере является политика одного источника или же Same Origin Policy. Она ограничивает доступ скриптов к ответам,
  загруженным с другого домена, протокола или порта. Это означает, что страница не может произвольно читать ответы другого сайта, даже если пользователь
  авторизован там. Такая политика защищает от утечек данных и атак.

  Для контролируемого междоменного обмена данными используется механизм CORS. Сервер явно указывает, какие источники имеют право обращаться к ресурсам.
  Если настройки CORS заданы неверно, браузер может заблокировать запрос, даже если сам сервер вернул корректный ответ.

  Отдельного внимания заслуживает работа с cookies и авторизацией. Современные браузеры строго ограничивают передачу cookies между доменами и применяют дополнительные
  политики, такие как SameSite. Неправильная конфигурация этих параметров может привести к тому, что пользователь неожиданно будет разлогинен или запросы к серверу
  перестанут работать.

  Также в процессе загрузки страницы могут возникать проблемы, связанные с безопасностью контента. Например, браузер блокирует смешанный контент, когда HTTPS страница
  пытается загрузить ресурсы по HTTP. Это делается для предотвращения атак, при которых злоумышленник может подменить небезопасный ресурс. Дополнительно применяются
  политики безопасности контента, которые ограничивают выполнение скриптов и загрузку ресурсов из непроверенных источников.

  Также существуют угрозы на уровне выполнения JavaScript, такие как XSS атаки, при которых вредоносный кот может быть внедрен в страницу. Браузеры и разработчики
  используют различные механизмы защиты, включая экранирование данных, строгие заголовки безопасности и Content Security Policy, чтобы минимизировать подобные риски.
